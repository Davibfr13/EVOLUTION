// Prisma schema optimized for PostgreSQL on Render
// Generated: 2025-10-30

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum InstanceStatus {
  connected
  disconnected
  connecting
  error
}

enum UserRole {
  ADMIN
  USER
  OPERATOR
}

enum MessageStatus {
  pending
  sent
  delivered
  failed
  read
}

// Core models
model User {
  id         String   @id @default(uuid())
  email      String   @unique
  name       String?
  password   String?  // hashed password
  role       UserRole @default(USER)
  active     Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // relations
  instances  Instance[]
  schedules  Schedule[]
  logs       Log[]
}

model Instance {
  id           String         @id @default(uuid())
  name         String
  instanceKey  String         @unique
  status       InstanceStatus @default(disconnected)
  qrcode       String?
  ownerId      String?        @db.Uuid
  owner        User?          @relation(fields: [ownerId], references: [id])
  webhookUrl   String?
  metadata     Json?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  // relations
  sessions     Session[]
  contacts     Contact[]
  messages     Message[]
}

model Session {
  id          String   @id @default(uuid())
  instanceId  String   @db.Uuid
  token       String?
  name        String?
  expiresAt   DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  instance    Instance @relation(fields: [instanceId], references: [id])
}

model Contact {
  id         String   @id @default(uuid())
  instanceId String   @db.Uuid
  waId       String   @map("wa_id") // e.g. phone number or WhatsApp id
  name       String?
  profile    Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  instance   Instance @relation(fields: [instanceId], references: [id])
  chats      Chat[]
  messages   Message[]
}

model Chat {
  id         String   @id @default(uuid())
  instanceId String   @db.Uuid
  title      String?
  isGroup    Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  instance   Instance @relation(fields: [instanceId], references: [id])
  messages   Message[]
  labels     Label[]  @relation("ChatLabels")
}

model Message {
  id            String        @id @default(uuid())
  instanceId    String        @db.Uuid
  chatId        String?       @db.Uuid
  contactId     String?       @db.Uuid
  templateId    String?       @db.Uuid
  content       String?       @db.Text
  mediaUrl      String?
  externalId    String?       @unique
  status        MessageStatus @default(pending)
  scheduledAt   DateTime?
  sentAt        DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  instance      Instance      @relation(fields: [instanceId], references: [id])
  chat          Chat?         @relation(fields: [chatId], references: [id])
  contact       Contact?      @relation(fields: [contactId], references: [id])
  template      Template?     @relation(fields: [templateId], references: [id])
}

model Template {
  id          String   @id @default(uuid())
  name        String   @unique
  body        String   @db.Text
  variables   String?  // JSON string or description of variables
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  messages    Message[]
}

model Schedule {
  id          String   @id @default(uuid())
  userId      String   @db.Uuid
  messageId   String?  @db.Uuid
  cron        String?  // cron expression for recurrence
  nextRunAt   DateTime?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User?    @relation(fields: [userId], references: [id])
  message     Message? @relation(fields: [messageId], references: [id])
}

model Log {
  id          String   @id @default(uuid())
  userId      String?  @db.Uuid
  instanceId  String?  @db.Uuid
  level       String   @default("info")
  message     String   @db.Text
  meta        Json?
  createdAt   DateTime @default(now())

  user        User?     @relation(fields: [userId], references: [id])
  instance    Instance? @relation(fields: [instanceId], references: [id])
}

// Auxiliary models
model Label {
  id        String   @id @default(uuid())
  name      String
  color     String?
  createdAt DateTime @default(now())
  chats     Chat[]   @relation("ChatLabels")
}

model Setting {
  id        String   @id @default(uuid())
  key       String   @unique
  value     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Webhook {
  id        String   @id @default(uuid())
  name      String
  url       String
  active    Boolean  @default(true)
  events    String[] @default([])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Queues / integrations placeholders
model Rabbitmq {
  id        String   @id @default(uuid())
  name      String
  uri       String
  createdAt DateTime @default(now())
}

// OpenAI / AI integrations (examples kept minimal)
model OpenaiCreds {
  id        String   @id @default(uuid())
  key       String
  name      String?
  createdAt DateTime @default(now())
}

// Indexes and additional notes

// Add any legacy tables here (if you prefer to introspect instead of migrate):
// - If you previously had different table names or casing, consider adding
//   @@map("legacy_table_name") on the model.

// End of schema
